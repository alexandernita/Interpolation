# 3.5.8-10(c)

import numpy as np
import matplotlib.pyplot as plt

# The inputs and computation of the h_i and alpha_i
n = 2

def f(x):
    return x**2*np.cos(x)-3*x

def df(x):
    return 2*x*np.cos(x)-x**2*np.sin(x)-3

x = [0.1, 0.2, 0.3]
a = [f(i) for i in x]
aa = [-2.8019975, -2.4533949]

h = [x[i+1]-x[i] for i in range(n)]

alphaA = [3*(a[1]-a[0])/h[0]-3*aa[0]]
alphaB = [3*aa[1]-3*(a[n]-a[n-1])/h[0]]
alphaC = [3*(a[i+1]-a[i])/h[i]-3*(a[i]-a[i-1])/h[i-1] for i in range(1,n)]
alpha = alphaA + alphaC + alphaB

# Solving the tridiagonal matrix equation using Algorithm 6.7
    # Step 1: define l's, m's and z's
l = [2*h[0]]
m = [0.5]
z = [alpha[0]/l[0]]

for i in range(1,n):
    l.append(2*(x[i+1]-x[i-1])-h[i-1]*m[i-1])
    m.append(h[i]/l[i])
    z.append((alpha[i]-h[i-1]*z[i-1])/l[i])

l.append(h[n-1]*(2-m[n-1]))
z.append((alpha[n]-h[n-1]*z[n-1])/l[n])

    # Step 2: solve for the c's, b's and d's
C = [z[n]]
c = []
b = []
d = []
B = []
D = []

for j in range(n+1):
    C.append(z[n-1-j] - m[n-1-j]*C[j])
    B.append((a[n-j]-a[n-1-j])/h[n-1-j]-h[n-1-j]*(C[j]+2*C[j+1])/3)
    D.append((C[j]-C[j+1])/(3*h[n-1-j]))

for k in range(n):
    c.append(C[n-k])
    b.append(B[n-1-k])
    d.append(D[n-1-k])

print("\n\n\t 3.5.8(c):")
print("\t-----------")
print("\n\t Clamped cubic spline through the three data points:\n")
print("\t n\t x_n \t y_n")
print("\t----------------------------")
for i in range(n+1):
    print("\t %d"%i,"\t %0.1f"%x[i],"\t %0.7f"%a[i])
print("\t----------------------------\n\n")

print("\t The following output gives the coefficients of the two cubic")
print("\t polynomials S_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3:")
print("\t---------------------------------------------------------\
------------------------------------------------------")
a = a[0:3]
for j in range(n):
    print("\t For S_%d"%j,"(x), the coefficients are:    a[%d]"%j,"= %0.5f"%a[j],\
          "   b[%d]"%j," = %0.5f"%b[j],\
          "   c[%d]"%j,"= %0.5f"%c[j],\
          "   d[%d]"%j,"= %0.5f"%d[j])
print("\t---------------------------------------------------------\
------------------------------------------------------")

# 6c: Error term

    # Step 1: define our f(x) and f'(x), 
    # and the cubic spline CS(x) as a 
    # piecewise function, and CS'(x)

x0 = x[0]
x1 = x[1]
x2 = x[2]
dx = x2-x1

def CS(x):
    if (x0 <= x) and (x < x1):
        return a[0]+b[0]*(x-x0)+c[0]*(x-x0)**2+d[0]*(x-x0)**3

    elif (x1 <= x) and (x < x2):
        return a[1]+b[1]*(x-x1)+c[1]*(x-x1)**2+d[1]*(x-x1)**3

    else:
        return a[1]+b[1]*(x2-x1)+c[1]*(x2-x1)**2+d[1]*(x2-x1)**3

def dCS(x):
    if (x0 <= x) and (x < x1):
        return b[0]+2*c[0]*(x-x0)+3*d[0]*(x-x0)**2

    elif (x1 <= x) and (x < x2):
        return b[1]+2*c[1]*(x-x1)+3*d[1]*(x-x1)**2

    else:
        return b[1]+2*c[1]*(x2-x1)+3*d[1]*(x2-x1)**2
 
    # Step 2: Compute the errors

print("\n\n\t 3.5.10(c):")
print("\t-----------")
print("\n\t The y-values were generated by the following function and it's derivative:\n")
print("\t f(x) = x^2cos(x) - 3x\n\t f'(x) = 2xcos(x)-x^2sin(x)-3.\n")
print("\t The errors in using the cubic spline S(x) to approximate f(0.18) are:")
print("\t--------------------------------------------")
err = abs(f(0.18)-CS(0.18))
derr = abs(df(0.18)-dCS(0.18))
print("\t E(0.18) = |f(0.18)-CS(0.18)| = %0.7f"%err)
print("\t E'(0.18) = |f'(0.18)-CS'(0.18)| = %0.7f"%derr)
print("\t--------------------------------------------")

# Plot the spline and data points

    # Step 1: Create the list Z of y-values of PL(t)
t = np.linspace(x0,x2)
Z = []
W = []
for i in range(len(t)):
   Z.append(CS(t[i]))
   W.append(f(t[i]))

    # Step 2: Plot    
B, BX = plt.subplots()
B1 = BX.plot(t,Z,color="r",linewidth=1)
B2 = BX.plot(t,W,color="k",linewidth=1)
BX.set_title("Plot of the cubic spline CS(x) through the data points.")
plt.axvline(color="k",linewidth=1)
plt.axhline(color="k",linewidth=1)
B3 = BX.plot(x,a,'o',color="b")
plt.show()


 
